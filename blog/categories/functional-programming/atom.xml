<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Functional Programming | fizwidget]]></title>
  <link href="http://fizwidget.github.io/blog/categories/functional-programming/atom.xml" rel="self"/>
  <link href="http://fizwidget.github.io/"/>
  <updated>2014-07-05T17:35:02+09:30</updated>
  <id>http://fizwidget.github.io/</id>
  <author>
    <name><![CDATA[James Russell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Functional Pipelines]]></title>
    <link href="http://fizwidget.github.io/blog/2014/07/05/functional-pipelines/"/>
    <updated>2014-07-05T12:45:10+09:30</updated>
    <id>http://fizwidget.github.io/blog/2014/07/05/functional-pipelines</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s say we&rsquo;ve got a list of student objects, and we want to get the ID numbers of the 10 youngest first-year students. Perhaps to send them a survey or something. I dunno.</p>

<p>The point is, how do we do it? If you&rsquo;d asked me a few years ago, I probably would&rsquo;ve written something horrible like this:</p>

<!-- more -->


<p>``` ruby
youngest_ids = []</p>

<p>youngest_to_oldest = students.sort_by { |s| s.age }
i = 0</p>

<p>for student in youngest_to_oldest
  if student.level == 1</p>

<pre><code>youngest_ids.push(student.id_number)
i += 1
</code></pre>

<p>  end
  if i == 10</p>

<pre><code>break
</code></pre>

<p>  end
end</p>

<p>return youngest_ids
```</p>

<p>If you asked me today, I&rsquo;d write something more like this:</p>

<p>``` ruby
students.select  { |s| s.level == 1 }</p>

<pre><code>    .sort_by { |s| s.age }
    .take(10)
    .collect { |s| s.id_number }
</code></pre>

<p>```</p>

<p>This is a much, much better approach. The main difference is that it&rsquo;s <em>declarative</em> rather than <em>imperative</em>. We&rsquo;re describing what we want, rather than spelling out exactly how to achieve it. This approach is easier to understand, easier to modify, less error-prone, more concise, and has the <em>potential</em> to perform better (the system could, for example, distribute the <code>select</code> operation over multiple cores).</p>

<p>I&rsquo;ve used Ruby in the above example, but you can write this kind of code in a bunch of different languages (Python, C#, and Java 8 to name a few of the more popular ones). You might also notice similarities to SQL. This is no coincidence: SQL is very much a declarative language.</p>

<p>So go forth and be functional!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nothin' but Single-Argument Functions]]></title>
    <link href="http://fizwidget.github.io/blog/2014/07/04/nothin-but-single-argument-functions/"/>
    <updated>2014-07-04T09:17:13+09:30</updated>
    <id>http://fizwidget.github.io/blog/2014/07/04/nothin-but-single-argument-functions</id>
    <content type="html"><![CDATA[<p>In a <a href="/blog/2014/07/03/nothin-but-functions/">previous post</a>, I talked about the fact that functions are the only thing a language needs to be Turing-complete. In this post I&rsquo;ll take it a little further: <em>single-argument functions</em> are all a language needs to be Turing-complete.</p>

<p>At first glance this seems counter-intuitive. Surely there are a <em>lot</em> of things we wouldn&rsquo;t be able to do&hellip;adding two numbers, comparing two strings, searching for a number in a list, etc. These functions would all require more than one argument.</p>

<!-- more -->


<p>If you read my previous post on functions, you might be thinking we could pass around linked lists to simulate multiple arguments. There&rsquo;s one problem with that though&hellip;the <code>make_list</code> function accepts two arguments. We can&rsquo;t use a function that takes multiple arguments to implement multi-argument functions. That&rsquo;d be assuming what we want to prove.</p>

<h2>Closures to the rescue</h2>

<p>Remember closures? In addition to their arguments, they can access variables from their enclosing scope. Turns out we can use this ability to simulate multi-argument functions. Let&rsquo;s try writing a function to concatenate two strings:</p>

<p>``` python
def concatenate(a):
  def concatenate_aux(b):</p>

<pre><code>return a + b
</code></pre>

<p>  return concatenate_aux</p>

<p>concatenate(&ldquo;Hello&rdquo;)(&ldquo;World&rdquo;) # => &ldquo;HelloWorld&rdquo;
```</p>

<p><em>(Ignore the fact that I&rsquo;ve implemented concatenation with <code>+</code>, which is essentially a multi-argument function. That&rsquo;s just for brevity.)</em></p>

<p>Tada! The top-level <code>concatenate</code> function returns another function, which returns the final result when called. The <code>concatenate_aux</code> function is a closure, meaning it still has access to <code>a</code> when we call it later on.</p>

<p>So, we can decompose an n-argument function into a series of n nested single-argument functions (this is known as <a href="http://en.wikipedia.org/wiki/Currying">currying</a>).</p>

<p>This opens up another interesting possibility&hellip;</p>

<h2>Partial function application</h2>

<p>If a function takes n arguments, we usually have to call it with n arguments &ndash; anything less results in an error. If we define functions like we did above though, we can <em>partially apply</em> them:</p>

<p><code>python
greet = concatenate("Hello, ")
</code></p>

<p>We&rsquo;ve now got a new function (an instance of <code>concatenate_aux</code>) that will prepend <code>"Hello, "</code> to whatever we give it:</p>

<p><code>python
greet("Fred") # =&gt; "Hello, Fred"
greet("Bob")  # =&gt; "Hello, Bob"
</code></p>

<p>This can actually be a useful technique. The way we did it above is kinda messy, but Python has a <a href="https://docs.python.org/3/library/functools.html#functools.partial">library function</a> to simplify the process. In some languages (e.g. Haskell) any function can be partially applied &ndash; no extra work needed.</p>

<h2>Conclusion</h2>

<ul>
<li>Single-argument functions are all a language needs to be Turing-complete.</li>
<li>Partial function application lets us build specialised functions out of more general ones.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nothin' but Functions]]></title>
    <link href="http://fizwidget.github.io/blog/2014/07/03/nothin-but-functions/"/>
    <updated>2014-07-03T16:59:34+09:30</updated>
    <id>http://fizwidget.github.io/blog/2014/07/03/nothin-but-functions</id>
    <content type="html"><![CDATA[<p>Imagine we&rsquo;re using a programming language that doesn&rsquo;t give us any way of defining data structures. No arrays, no structs, no classes. Nothing. All we can do is define and call functions.</p>

<p>We need to work with a collection of items. Are we screwed?</p>

<!-- more -->


<h2>A list made of functions</h2>

<p>Turns out the answer is no. We can create linked lists, quite literally, out of functions:</p>

<p>``` python
def make_list(head, tail):
  def node(operation):</p>

<pre><code>if operation == "head":
  return head
elif operation == "tail":
  return tail
</code></pre>

<p>  return node
```</p>

<p>The <code>make_list</code> function accepts a <code>head</code> (the data item we want to store), and a <code>tail</code> (the next node in the list). We can use it to construct the list <code>[1, 2, 3]</code> as follows:</p>

<p><code>python
items = make_list(1, make_list(2, make_list(3, None)))
</code></p>

<p>When we call <code>make_list</code>, it returns an instance of the <code>node</code> function. This function accepts a single argument and returns the head or the tail based on the value of that argument.</p>

<p>Let&rsquo;s give it a try:</p>

<p><code>python
items                         # =&gt; &lt;function make_node.&lt;locals&gt;.node at 0x10987e598&gt;
items("head")                 # =&gt; 1
items("tail")                 # =&gt; &lt;function make_node.&lt;locals&gt;.node at 0x10987e620&gt;
items("tail")("head")         # =&gt; 2
items("tail")("tail")("head") # =&gt; 3
items("tail")("tail")("tail") # =&gt; None
</code></p>

<p>Neat! We can see that both <code>items</code> and <code>items("tail")</code> are instances of the <code>node</code> function, and that <code>items("head")</code> returns the value we stored in the first node.</p>

<p>Let&rsquo;s write a function to print the list:</p>

<p>``` python
def print_list(items):
  if items:</p>

<pre><code>print(items("head"))
print_list(items("tail"))
</code></pre>

<p>print_list(items)
```</p>

<p>As you&rsquo;d expect, it prints out 1 2 3.</p>

<h2>Closures</h2>

<p>A closure is a function that has access to the variables from the scope it was defined in. The <code>node</code> function is a good example of this: it accesses <code>head</code> and <code>tail</code>. These variables aren&rsquo;t explicitly passed in as arguments, but <code>node</code> can access them all the same. Each time we call <code>make_list</code>, a new instance of <code>node</code> is returned that references the new <code>head</code> and <code>tail</code> arguments.</p>

<p>Our list is nothing more than a chain of nested closures. When we call the outermost closure and pass it <code>"tail"</code> as an argument, it returns the next closure in the chain (i.e. the next node in the list).</p>

<h2>Conclusion</h2>

<p>We&rsquo;ve really just scratched the surface here &ndash; it&rsquo;s not hard to see that we could create more complex data structures using similar techniques. We could even use functions to define <em>numbers</em> by representing the nth integer as a series of n nested functions.</p>

<p>This all hints at a deeper fact: if a language allows you to define and apply functions, that language is Turing-complete (meaning it lets you compute anything that can be computed). The <a href="http://palmstroem.blogspot.com.au/2012/05/lambda-calculus-for-absolute-dummies.html">lambda calculus</a> is the canonical example of such a language.</p>

<p>Neat, huh?</p>
]]></content>
  </entry>
  
</feed>
