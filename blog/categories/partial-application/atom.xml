<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Partial Application | fizwidget]]></title>
  <link href="http://fizwidget.github.io/blog/categories/partial-application/atom.xml" rel="self"/>
  <link href="http://fizwidget.github.io/"/>
  <updated>2014-07-05T16:08:11+09:30</updated>
  <id>http://fizwidget.github.io/</id>
  <author>
    <name><![CDATA[James Russell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nothin' but Single-Argument Functions]]></title>
    <link href="http://fizwidget.github.io/blog/2014/07/04/nothin-but-single-argument-functions/"/>
    <updated>2014-07-04T09:17:13+09:30</updated>
    <id>http://fizwidget.github.io/blog/2014/07/04/nothin-but-single-argument-functions</id>
    <content type="html"><![CDATA[<p>In a <a href="/blog/2014/07/03/nothin-but-functions/">previous post</a>, I talked about the fact that functions are the only thing a language needs to be Turing-complete. In this post I&rsquo;m going to take it a little further: <em>single-argument functions</em> are all a language needs to be Turing-complete.</p>

<p>At first glance that seems weird. Surely there are a <em>lot</em> of things this would prevent us from doing&hellip;adding two numbers, comparing two strings, searching for a number in a list, etc. These functions would all require more than one argument.</p>

<!-- more -->


<p>If you read my previous post, you might be thinking of passing a linked list to simulate multiple arguments. There&rsquo;s one problem with that though&hellip;the <code>make_list</code> function accepts two arguments. We can&rsquo;t use a function that takes multiple arguments to implement multi-argument functions. That&rsquo;d be assuming what we want to prove :P</p>

<h2>Closures come to the rescue</h2>

<p>Remember closures? In addition to their arguments, they can access variables from their enclosing scope. We can use this ability to simulate multi-argument functions. Let&rsquo;s try writing a function function to concatenate two strings:</p>

<p>``` python
def concatenate(a):
  def concatenate_aux(b):</p>

<pre><code>return a + b
</code></pre>

<p>  return concatenate_aux</p>

<p>concatenate(&ldquo;Hello&rdquo;)(&ldquo;World&rdquo;) # => &ldquo;HelloWorld&rdquo;
```</p>

<p>Tada! The top-level <code>add</code> function returns another function, which will in-turn return the final result. The <code>concatenate_aux</code> function is a closure, meaning it still has access to <code>a</code> when we call it later on.</p>

<p>So, we can decompose an n-argument function into a series of n nested single-argument functions (a process known as <a href="http://en.wikipedia.org/wiki/Currying">currying</a>).</p>

<p>This opens up an interesting possibility&hellip;</p>

<h2>Partial application</h2>

<p>Typically, if a function takes n arguments, you have to call it with n arguments. Anything less results in an error. If we define functions like we did above though, we can <em>partially apply</em> them:</p>

<p><code>python
greet = concatenate("Hello, ")
</code></p>

<p>We&rsquo;ve now got a new function (an instance of <code>concatenate_aux</code>) that will prepend <code>"Hello, "</code> to whatever we give it:</p>

<p><code>python
greet("Fred") # =&gt; "Hello, Fred"
greet("Bob")  # =&gt; "Hello, Bob"
</code></p>

<h2>Conclusion</h2>

<p>So, single-argument functions are all a language needs to be Turing-complete. Neat, but not very practical.</p>

<p>Partial application on the other hand is actually a useful technique. Not so much in Python (due to the messy way we&rsquo;d have to define functions) but some languages make it really easy. In Haskell we can partially apply any function, without having to to through the hassle of defining them in a weird way. This lets us build specialised functions from more general ones.</p>
]]></content>
  </entry>
  
</feed>
